# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T09:09:08+00:00



import argparse
import json
import os
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, UnsuportedSecurityStub
from fastapi import Query
from starlette.requests import Request

from models import (
    Account,
    AccountId,
    AccountStage,
    AccountStageId,
    AccountTier,
    AccountTierId,
    AccountUpsert,
    Action,
    ActionId,
    Activity,
    ActivityHistory,
    BulkJob,
    Cadence,
    CadenceExport,
    CadenceId,
    CadenceImport,
    CadenceMembership,
    CalendarEvent,
    Call,
    CallDataRecord,
    CallInstruction,
    City,
    ConversationsCall,
    Country,
    CreatedAt,
    CreatedAt3,
    CrmActivity,
    CrmActivityId,
    CrmId,
    CurrentState,
    CustomField,
    CustomFields,
    Disposition,
    DueOn,
    Email,
    EmailAddresses,
    EmailTemplate,
    EmailTemplateId,
    EventIds,
    ExternalEmail,
    Group,
    GroupId,
    GroupId1,
    Guid,
    ICalUids,
    Id,
    Ids,
    Ids28,
    Ids29,
    Import,
    ImportId,
    Industry,
    JobDataCreationResult,
    JobSeniority,
    LastContacted,
    LiveWebsiteTrackingParameter,
    Locale,
    Locales,
    Meeting,
    MeetingSetting,
    MimeEmailPayload,
    MultitouchGroupId,
    Name,
    Note,
    OccurredAt,
    OwnedByGuid,
    OwnerCrmId,
    OwnerId,
    OwnerId1,
    PendingEmail,
    Person,
    Personalization,
    PersonId,
    PersonIds,
    PersonStage,
    PersonStageId,
    PersonUpsert,
    PhoneNumberAssignment,
    RecordingSetting,
    ResourceId,
    RoleId,
    SavedListView,
    ScopedFields,
    SentAt,
    Sentiment,
    StarredByGuid,
    StartTime,
    State,
    Status,
    Step,
    StepId,
    Subscription,
    Tag1,
    TagId,
    TagIds,
    Task,
    TaskIds,
    TaskType,
    Team,
    TeamTemplate,
    TeamTemplateId,
    Title,
    UpdatedAt,
    UpdatedAt5,
    UpdatedAt6,
    User,
    UserGuid,
    UserGuids,
    UserId,
    UserIds,
    UserRelationships,
    V2BulkJobsBulkJobsIdJobDataGetResponse,
    V2BulkJobsBulkJobsIdResultsGetResponse,
    V2BulkJobsGetResponse,
    V2CalendarEventsGetResponse,
    V2ThirdPartyLiveFeedItemsPostResponse,
    V2WebhookSubscriptionsGetResponse,
    Website,
    WorkCountry,
)
from models.V2Accounts import JsonGetResponse
from models.V2AccountStages import JsonGetResponse
from models.V2AccountTiers import JsonGetResponse
from models.V2ActionDetailsCallInstructions import JsonGetResponse
from models.V2Actions import JsonGetResponse
from models.V2ActivitiesCalls import JsonGetResponse
from models.V2ActivitiesEmails import JsonGetResponse
from models.V2CadenceMemberships import JsonGetResponse
from models.V2Cadences import JsonGetResponse
from models.V2CallDataRecords import JsonGetResponse
from models.V2CallDispositions import JsonGetResponse
from models.V2CallSentiments import JsonGetResponse
from models.V2CrmActivities import JsonGetResponse
from models.V2CrmActivityFields import JsonGetResponse
from models.V2CrmUsers import JsonGetResponse
from models.V2CustomFields import JsonGetResponse
from models.V2EmailTemplateAttachments import JsonGetResponse
from models.V2EmailTemplates import JsonGetResponse
from models.V2Groups import JsonGetResponse
from models.V2Imports import JsonGetResponse
from models.V2Meetings import JsonGetResponse
from models.V2MeetingsSettingsSearches import JsonPostResponse
from models.V2Notes import JsonGetResponse
from models.V2PendingEmails import JsonGetResponse
from models.V2People import JsonGetResponse
from models.V2PersonStages import JsonGetResponse
from models.V2PhoneNumberAssignments import JsonGetResponse
from models.V2PhoneNumbersCallerIds import JsonGetResponse
from models.V2SavedListViews import JsonGetResponse
from models.V2Steps import JsonGetResponse
from models.V2Successes import JsonGetResponse
from models.V2Tags import JsonGetResponse
from models.V2Tasks import JsonGetResponse
from models.V2TeamTemplateAttachments import JsonGetResponse
from models.V2TeamTemplates import JsonGetResponse
from models.V2Users import JsonGetResponse

app = MCPProxy(
    contact={'email': 'integrations@salesloft.com', 'x-twitter': 'SalesLoft'},
    description='SalesLoft helps transform sales teams into modern sales organizations  - converting more target accounts into customer accounts\n',
    title='SalesLoft Platform',
    version='v2',
    servers=[{'url': 'https://api.salesloft.com'}],
)


@app.get(
    '/v2/account_stages.json',
    description=""" Fetches multiple account stage records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['account_stage_management', 'account_management'],
)
def get_v2_account_stages_json(
    ids: Optional[Ids] = None,
    updated_at: Optional[UpdatedAt] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List account stages
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/account_stages/{id}.json',
    description=""" Fetches an account stage, by ID only.
 """,
    tags=['account_management', 'account_stage_management'],
)
def get_v2_account_stages__id_json(id: str):
    """
    Fetch an account stage
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/account_tiers.json',
    description=""" Fetches multiple account tier records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['account_tier_management'],
)
def get_v2_account_tiers_json(
    ids: Optional[Ids] = None,
    name: Optional[Name] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List Account Tiers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/account_tiers/{id}.json',
    description=""" Fetches an account tier, by ID only.
 """,
    tags=['account_management', 'account_tier_management'],
)
def get_v2_account_tiers__id_json(id: str):
    """
    Fetch an account tier
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/account_upserts.json',
    description=""" Upserts an account record. The upsert_key dictates how the upsert will be performed. The create and update behavior
is exactly the same as the individual create and update endpoints.
 """,
    tags=['account_management'],
)
def post_v2_account_upserts_json(request: Request):
    """
    Upsert an account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/accounts.json',
    description=""" Fetches multiple account records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['account_management', 'account_stage_management', 'account_tier_management'],
)
def get_v2_accounts_json(
    ids: Optional[Ids] = None,
    crm_id: Optional[CrmId] = None,
    tag: Optional[Tag1] = None,
    tag_id: Optional[TagId] = None,
    created_at: Optional[CreatedAt] = None,
    updated_at: Optional[UpdatedAt] = None,
    domain: Optional[str] = None,
    website: Optional[Website] = None,
    archived: Optional[bool] = None,
    name: Optional[Name] = None,
    account_stage_id: Optional[AccountStageId] = None,
    account_tier_id: Optional[AccountTierId] = None,
    owner_id: Optional[OwnerId] = None,
    owner_is_active: Optional[bool] = None,
    last_contacted: Optional[LastContacted] = None,
    custom_fields: Optional[CustomFields] = None,
    industry: Optional[Industry] = None,
    country: Optional[Country] = None,
    state: Optional[State] = None,
    city: Optional[City] = None,
    owner_crm_id: Optional[OwnerCrmId] = None,
    locales: Optional[Locales] = None,
    user_relationships: Optional[UserRelationships] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/accounts.json',
    description=""" Creates an account.

"domain" must be unique on the current team.
 """,
    tags=['account_management', 'user_management'],
)
def post_v2_accounts_json(request: Request):
    """
    Create an account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/accounts/{id}.json',
    description=""" Deletes an account. This operation is not reversible without contacting support.
This operation can be called multiple times successfully.

Deleting an account will remove all connected people from that account.
 """,
    tags=['account_management', 'user_management'],
)
def delete_v2_accounts__id_json(id: str):
    """
    Delete an account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/accounts/{id}.json',
    description=""" Fetches an account, by ID only.
 """,
    tags=['account_management'],
)
def get_v2_accounts__id_json(id: str):
    """
    Fetch an account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/accounts/{id}.json',
    description=""" Updates an account.

"domain" must be unique on the current team.
 """,
    tags=['account_management'],
)
def put_v2_accounts__id_json(id: str, request: Request = ...):
    """
    Update an existing Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/action_details/call_instructions.json',
    description=""" Fetches multiple call instruction records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['call_record_management', 'activity_management'],
)
def get_v2_action_details_call_instructions_json(
    ids: Optional[Ids] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List call instructions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/action_details/call_instructions/{id}.json',
    description=""" Fetches a call instruction, by ID only.
 """,
    tags=['call_record_management', 'activity_management'],
)
def get_v2_action_details_call_instructions__id_json(id: str):
    """
    Fetch a call instructions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/actions.json',
    description=""" Fetches multiple action records. The records can be filtered, paged, and sorted according to
the respective parameters. Only actions that are currently "in_progess" will be returned by
this endpoint.

If the requester is not an admin, this endpoint will only return actions belonging to the requester.
If the request is an admin, this endpoint will return actions for the entire team. Additionaly, an admin
may use the user_guid parameter to request actions that belong to specific users on the team.
 """,
    tags=['action_management', 'cadence_management'],
)
def get_v2_actions_json(
    ids: Optional[Ids] = None,
    step_id: Optional[int] = None,
    type: Optional[str] = None,
    due_on: Optional[DueOn] = None,
    user_guid: Optional[UserGuid] = None,
    person_id: Optional[PersonId] = None,
    cadence_id: Optional[CadenceId] = None,
    multitouch_group_id: Optional[MultitouchGroupId] = None,
    updated_at: Optional[UpdatedAt] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List actions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/actions/{id}.json',
    description=""" Fetches an action, by ID only.
This endpoint will only return actions that are in_progress or pending_activity.
Once an action is complete, the request for that action will return a 404 status code.
 """,
    tags=['action_management'],
)
def get_v2_actions__id_json(id: str):
    """
    Fetch an action
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/activities.json',
    description=""" Creates an activity. An activity will mark the associated action as completed. Currently,
only certain action types can have an activity explicitly created for them.
 """,
    tags=['activity_management', 'action_management', 'crm_activity_management'],
)
def post_v2_activities_json(request: Request):
    """
    Create an activity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/activities/calls.json',
    description=""" Fetches multiple call records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['call_record_management', 'call_analysis', 'activity_management'],
)
def get_v2_activities_calls_json(
    ids: Optional[Ids] = None,
    created_at: Optional[CreatedAt] = None,
    updated_at: Optional[UpdatedAt] = None,
    user_guid: Optional[UserGuid] = None,
    person_id: Optional[PersonId] = None,
    sentiment: Optional[Sentiment] = None,
    disposition: Optional[Disposition] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List calls
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/activities/calls.json',
    description=""" Creates a call. The parameters of this endpoint can be used to create an action
and ensure that the CRM Task is mapped correctly.
 """,
    tags=['activity_management', 'call_record_management', 'call_analysis'],
)
def post_v2_activities_calls_json(request: Request):
    """
    Create a call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/activities/calls/{id}.json',
    description=""" Fetches a call, by ID only.
 """,
    tags=['activity_management', 'call_record_management'],
)
def get_v2_activities_calls__id_json(id: str):
    """
    Fetch a call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/activities/emails.json',
    description=""" Fetches multiple email records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['email_management', 'activity_management', 'crm_activity_management'],
)
def get_v2_activities_emails_json(
    ids: Optional[Ids] = None,
    updated_at: Optional[UpdatedAt] = None,
    bounced: Optional[bool] = None,
    crm_activity_id: Optional[CrmActivityId] = None,
    action_id: Optional[ActionId] = None,
    user_id: Optional[UserId] = None,
    status: Optional[Status] = None,
    cadence_id: Optional[CadenceId] = None,
    step_id: Optional[StepId] = None,
    one_off: Optional[bool] = None,
    scoped_fields: Optional[ScopedFields] = None,
    person_id: Optional[PersonId] = None,
    email_addresses: Optional[EmailAddresses] = None,
    personalization: Optional[Personalization] = None,
    sent_at: Optional[SentAt] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List emails
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/activities/emails/{id}.json',
    description=""" Fetches an email, by ID only.
 """,
    tags=['email_management', 'activity_management'],
)
def get_v2_activities_emails__id_json(id: str):
    """
    Fetch an email
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/activity_histories',
    description=""" Fetches all of the customer's past activities for your application. Returns all the Activities that are found on the Salesloft Activity Feed. <a href="/activity-history.html" target="_blank" rel="noopener noreferrer">Visit here for more details</a>. """,
    tags=['activity_management', 'crm_activity_management'],
)
def get_v2_activity_histories(
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    type: Optional[str] = None,
    field_resource: Optional[str] = Query(None, alias='_resource'),
    occurred_at: Optional[OccurredAt] = None,
    pinned: Optional[bool] = None,
    resource_type: Optional[str] = None,
    resource_id: Optional[ResourceId] = None,
    updated_at: Optional[UpdatedAt5] = None,
    user_guid: Optional[str] = None,
):
    """
    List Past Activities
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/bulk_jobs',
    description=""" Fetches multiple bulk job records. The records can be filtered, paged, and sorted according to the respective parameters. """,
    tags=['bulk_job_management'],
)
def get_v2_bulk_jobs(
    state: Optional[State] = None,
    id: Optional[Id] = None,
    per_page: Optional[int] = None,
):
    """
    List bulk jobs
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/bulk_jobs',
    description=""" Creates a bulk job. The type of the bulk job must be included when created.

For additional information on creating bulk jobs, the types of supported bulk jobs, and examples of the bulk job flow, visit the <a href="/bulk.html" target="_blank" rel="noopener noreferrer">bulk job details page</a>.
 """,
    tags=['bulk_job_management'],
)
def post_v2_bulk_jobs(request: Request):
    """
    Create a bulk job
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/bulk_jobs/{bulk_jobs_id}/job_data',
    description=""" Fetches multiple job data records for a given bulk job. Pagination is not supported, but cursor based polling is via use of the `id[gt]` filter. Pass the last id seen (i.e. `id[gt]=1234`) in order to get the next batch of records. """,
    tags=['bulk_job_management'],
)
def get_v2_bulk_jobs__bulk_jobs_id_job_data(
    bulk_jobs_id: int,
    status: Optional[Status] = None,
    id: Optional[Id] = None,
    per_page: Optional[int] = None,
):
    """
    List job data for a bulk job
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/bulk_jobs/{bulk_jobs_id}/job_data',
    description=""" Upload job data for the specified bulk job. Upload an array of objects, where element contains the parameters necessary to execute the individual calls. Each call to this endpoint can handle up to 5,000 records at a time. There is no limit to how many times you can create job data for a given bulk job.

For additional information on creating bulk jobs, the types of supported bulk jobs, and examples of the bulk job flow, visit the <a href="/bulk.html" target="_blank" rel="noopener noreferrer">bulk job details page</a>.
 """,
    tags=['bulk_job_management'],
)
def post_v2_bulk_jobs__bulk_jobs_id_job_data(bulk_jobs_id: int, request: Request = ...):
    """
    Create job data for a bulk job
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/bulk_jobs/{bulk_jobs_id}/results',
    description=""" Fetches multiple job data records for a completed bulk job. Note that until a bulk job's state is set to `done` the returned `data` will be an empty array. Pagination is not supported, but cursor based polling is via use of the `id[gt]` filter. Pass the last id seen (i.e. `id[gt]=1234`) in order to get the next batch of records. """,
    tags=['bulk_job_management'],
)
def get_v2_bulk_jobs__bulk_jobs_id_results(
    bulk_jobs_id: int,
    status: Optional[Status] = None,
    id: Optional[Id] = None,
    per_page: Optional[int] = None,
):
    """
    List job data for a completed bulk job.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/bulk_jobs/{id}',
    description=""" Fetches a bulk job, by ID only. """,
    tags=['bulk_job_management'],
)
def get_v2_bulk_jobs__id(id: int):
    """
    Fetch a bulk job
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/bulk_jobs/{id}',
    description=""" Updates a bulk job's name and / or marks a bulk job as 'ready_to_execute'.  May only be updated if the bulk job is still in an "open" state.

For additional information on creating bulk jobs, the types of supported bulk jobs, and examples of the bulk job flow, visit the <a href="/bulk.html" target="_blank" rel="noopener noreferrer">bulk job details page</a>.
 """,
    tags=['bulk_job_management'],
)
def put_v2_bulk_jobs__id(id: int, request: Request = ...):
    """
    Update a bulk job
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/cadence_exports/{id}.json',
    description=""" Exports a cadence as JSON.
 """,
    tags=['cadence_management'],
)
def get_v2_cadence_exports__id_json(id: str):
    """
    Export a cadence
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/cadence_imports.json',
    description=""" New cadences can be created or steps can be imported onto existing cadences which do not have steps.
<a href="/cadence-imports.html" target="_blank" rel="noopener noreferrer">Visit here for more details</a>.
 """,
    tags=['cadence_management', 'import_management'],
)
def post_v2_cadence_imports_json(request: Request):
    """
    Import cadences from JSON
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/cadence_memberships.json',
    description=""" Fetches multiple cadence membership records. The records can be filtered, paged, and sorted according to
the respective parameters. A cadence membership is the association between a person and their current and
historical time on a cadence. Cadence membership records are mutable and change over time. If a person is
added to a cadence and re-added to the same cadence in the future, there is a single membership record.
 """,
    tags=['cadence_management', 'cadence_membership_management'],
)
def get_v2_cadence_memberships_json(
    ids: Optional[Ids] = None,
    person_id: Optional[int] = None,
    cadence_id: Optional[int] = None,
    updated_at: Optional[UpdatedAt6] = None,
    currently_on_cadence: Optional[bool] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List cadence memberships
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/cadence_memberships.json',
    description=""" Adds a person to a cadence. person_id and cadence_id are required, and must be visible to the authenticated user. user_id will
default to the authenticated user, but can be set to any visible user on the authenticated team.

A person cannot be added to a cadence on behalf of a teammate unless the cadence is a team cadence, the cadence is owned by
the teammate, or the teammate has the Personal Cadence Admin permission.
 """,
    tags=['cadence_membership_management', 'cadence_management'],
)
def post_v2_cadence_memberships_json(
    person_id: int,
    cadence_id: int = ...,
    user_id: Optional[int] = None,
    step_id: Optional[int] = None,
):
    """
    Create a cadence membership
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/cadence_memberships/{id}.json',
    description=""" Cadence Membership
 """,
    tags=['cadence_membership_management'],
)
def delete_v2_cadence_memberships__id_json(id: str):
    """
    Delete a cadence membership
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/cadence_memberships/{id}.json',
    description=""" Fetches a cadence membership, by ID only.
 """,
    tags=['cadence_management', 'cadence_membership_management'],
)
def get_v2_cadence_memberships__id_json(id: str):
    """
    Fetch a cadence membership
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/cadences.json',
    description=""" Fetches multiple cadence records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['cadence_management', 'cadence_membership_management'],
)
def get_v2_cadences_json(
    ids: Optional[Ids] = None,
    updated_at: Optional[UpdatedAt6] = None,
    team_cadence: Optional[bool] = None,
    shared: Optional[bool] = None,
    owned_by_guid: Optional[OwnedByGuid] = None,
    people_addable: Optional[bool] = None,
    name: Optional[Name] = None,
    group_ids: Optional[str] = None,
    archived: Optional[bool] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List cadences
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/cadences/{id}.json',
    description=""" Fetches a cadence, by ID only.
 """,
    tags=['cadence_management'],
)
def get_v2_cadences__id_json(id: str):
    """
    Fetch a cadence
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/calendar/events',
    description=""" Returns all calendar events, paginated and filtered by the date. """,
    tags=['calendar_event_management'],
)
def get_v2_calendar_events(
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    start_time: Optional[str] = None,
    end_time: Optional[str] = None,
    user_guid: Optional[str] = None,
):
    """
    List calendar events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/calendar/events/upsert',
    description="""   Upserts a calendar event object.
  Upsert key is a combination of `id` and `i_cal_uid` scoped to the given `calendar_id`.
  Bulk operations:
  This endpoint is used for bulk operations, see https://developers.salesloft.com/bulk.html for integration instructions.
  Use `calendar/events/upsert` as an event type, and this spec as a data spec.
  This endpoint should be used directly for the time sensitive calendar event updates.
 """,
    tags=['calendar_event_management'],
)
def post_v2_calendar_events_upsert(request: Request):
    """
    Upsert a calendar event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/call_data_records.json',
    description=""" Fetches multiple call data records. The records can be filtered, paged, and sorted according to
the respective parameters.

Call data records are records of all inbound and outbound calls through Salesloft. A call data record may
be associated with a call, but does not have to be.
 """,
    tags=['call_record_management', 'activity_management'],
)
def get_v2_call_data_records_json(
    ids: Optional[Ids] = None,
    has_call: Optional[bool] = None,
    created_at: Optional[CreatedAt] = None,
    updated_at: Optional[UpdatedAt6] = None,
    user_guid: Optional[UserGuid] = None,
    person_id: Optional[PersonId] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List call data records
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/call_data_records/{id}.json',
    description=""" Fetches a call data record, by ID only.
 """,
    tags=['call_record_management'],
)
def get_v2_call_data_records__id_json(id: str):
    """
    Fetch a call data record
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/call_dispositions.json',
    description=""" Fetches multiple call disposition records. The records can be sorted according to
the respective parameters. Call dispositions must be configured in application. This will
change in the future, but please contact us if you have a pressing use case.
 """,
    tags=['call_record_management', 'call_analysis'],
)
def get_v2_call_dispositions_json(
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List call dispositions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/call_sentiments.json',
    description=""" Fetches multiple call sentiment records. The records can be sorted according to
the respective parameters. Call sentiments must be configured in application. This will
change in the future, but please contact us if you have a pressing use case.
 """,
    tags=['call_analysis', 'activity_management'],
)
def get_v2_call_sentiments_json(
    name: Optional[str] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List call sentiments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/conversations/calls',
    description=""" Enqueue a Conversations Call for processing """,
    tags=['activity_management', 'call_record_management', 'meeting_management'],
)
def post_v2_conversations_calls(request: Request):
    """
    Create Conversations Call
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/crm_activities.json',
    description=""" Fetches multiple crm activity records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['activity_management', 'crm_activity_management'],
)
def get_v2_crm_activities_json(
    ids: Optional[Ids] = None,
    updated_at: Optional[UpdatedAt6] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List crm activities
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/crm_activities/{id}.json',
    description=""" Fetches a crm activity, by ID only.
 """,
    tags=['activity_management', 'crm_activity_management'],
)
def get_v2_crm_activities__id_json(id: str):
    """
    Fetch a crm activity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/crm_activity_fields.json',
    description=""" Fetches multiple crm activity field records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['crm_activity_management'],
)
def get_v2_crm_activity_fields_json(
    source: Optional[str] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List crm activity fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/crm_users.json',
    description=""" Crm Users
 """,
    tags=['crm_user_management', 'user_management'],
)
def get_v2_crm_users_json(
    ids: Optional[Ids] = None,
    crm_id: Optional[CrmId] = None,
    user_id: Optional[UserId] = None,
    user_guid: Optional[UserGuid] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
):
    """
    List crm users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/custom_fields.json',
    description=""" Fetches multiple custom field records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['custom_field_management'],
)
def get_v2_custom_fields_json(
    ids: Optional[Ids] = None,
    field_type: Optional[str] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List custom fields
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/custom_fields.json',
    description=""" Creates a custom field.
 """,
    tags=['custom_field_management'],
)
def post_v2_custom_fields_json(request: Request):
    """
    Create a custom field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/custom_fields/{id}.json',
    description=""" Deletes a custom field.
 """,
    tags=['custom_field_management'],
)
def delete_v2_custom_fields__id_json(id: str):
    """
    Delete a custom field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/custom_fields/{id}.json',
    description=""" Fetches a custom field, by ID only.
 """,
    tags=['custom_field_management'],
)
def get_v2_custom_fields__id_json(id: str):
    """
    Fetch a custom field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/custom_fields/{id}.json',
    description=""" Update a custom field.
 """,
    tags=['custom_field_management'],
)
def put_v2_custom_fields__id_json(id: str, request: Request = ...):
    """
    Update a custom field
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/email_template_attachments.json',
    description=""" Fetches multiple email template attachment records. The records can be filtered and paged according to
the respective parameters.
 """,
    tags=['email_template_management'],
)
def get_v2_email_template_attachments_json(
    ids: Optional[Ids] = None,
    email_template_id: Optional[EmailTemplateId] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List email template attachments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/email_templates.json',
    description=""" Fetches multiple email template records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['email_template_management', 'cadence_management', 'activity_management'],
)
def get_v2_email_templates_json(
    ids: Optional[Ids] = None,
    updated_at: Optional[UpdatedAt6] = None,
    linked_to_team_template: Optional[bool] = None,
    search: Optional[str] = None,
    tag_ids: Optional[TagIds] = None,
    tag: Optional[Tag1] = None,
    filter_by_owner: Optional[bool] = None,
    group_id: Optional[GroupId] = None,
    include_cadence_templates: Optional[bool] = None,
    include_archived_templates: Optional[bool] = None,
    cadence_id: Optional[CadenceId] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List email templates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/email_templates/{id}.json',
    description=""" Fetches an email template, by ID only.
 """,
    tags=['email_template_management', 'activity_management'],
)
def get_v2_email_templates__id_json(id: str, include_signature: Optional[bool] = None):
    """
    Fetch an email template
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/external_emails.json',
    description=""" Creates an external email object.
 """,
    tags=['external_email_management', 'email_management', 'activity_management'],
)
def post_v2_external_emails_json(request: Request):
    """
    Create an External Email
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/groups.json',
    description=""" Fetches multiple group records. The records can be filtered, and sorted according to
the respective parameters.
 """,
    tags=['group_management', 'account_management'],
)
def get_v2_groups_json(
    ids: Optional[Ids] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
):
    """
    List groups
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/groups/{id}.json',
    description=""" Fetches a group, by ID only.
 """,
    tags=['group_management'],
)
def get_v2_groups__id_json(id: str):
    """
    Fetch a group
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/imports.json',
    description=""" Fetches multiple imports.
 """,
    tags=['import_management'],
)
def get_v2_imports_json(
    ids: Optional[Ids] = None,
    user_ids: Optional[UserIds] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List imports
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/imports.json',
    description=""" Creates an import.
 """,
    tags=['import_management'],
)
def post_v2_imports_json(request: Request):
    """
    Create an import
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/imports/{id}.json',
    description=""" Deletes an import, by ID only. The associated people can be deleted as part of the deletion process.

Admin users can access imports for the entire team, but non-admin users can only access their own imports.
 """,
    tags=['import_management'],
)
def delete_v2_imports__id_json(id: str, undo: Optional[str] = None):
    """
    Delete an import
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/imports/{id}.json',
    description=""" Fetches an import, by ID only.

Admin users can access imports for the entire team, but non-admin users can only access their own imports.
 """,
    tags=['import_management'],
)
def get_v2_imports__id_json(id: str):
    """
    Fetch an import
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/imports/{id}.json',
    description=""" Updates an import, by ID only.

Admin users can access imports for the entire team, but non-admin users can only access their own imports.
 """,
    tags=['import_management'],
)
def put_v2_imports__id_json(id: str, request: Request = ...):
    """
    Update an import
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/live_website_tracking_parameters.json',
    description=""" Creates a Live Website Tracking parameter to identify a person
 """,
    tags=['activity_management'],
)
def post_v2_live_website_tracking_parameters_json(request: Request):
    """
    Create an Live Website Tracking Parameter
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/me.json',
    description=""" Authenticated user information. This endpoint does not accept any parameters as it is
represents your authenticated user. The "Users" resource provides user information
for other users on the team.
 """,
    tags=['user_management', 'account_management'],
)
def get_v2_me_json():
    """
    Fetch current user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/meetings.json',
    description=""" Fetches multiple meeting records. The records can be filtered, paged, and sorted according to the respective parameters.
Meetings resource is responsible for events created via the Salesloft platform using calendaring features.
These events can relate to cadences, people, and accounts.
 """,
    tags=['meeting_management', 'calendar_event_management', 'task_management'],
)
def get_v2_meetings_json(
    ids: Optional[Ids] = None,
    status: Optional[str] = None,
    person_id: Optional[str] = None,
    account_id: Optional[str] = None,
    person_ids: Optional[PersonIds] = None,
    event_ids: Optional[EventIds] = None,
    i_cal_uids: Optional[ICalUids] = None,
    task_ids: Optional[TaskIds] = None,
    include_meetings_settings: Optional[bool] = None,
    start_time: Optional[StartTime] = None,
    user_guids: Optional[UserGuids] = None,
    show_deleted: Optional[bool] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List meetings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/meetings/settings/searches.json',
    description=""" Fetches multiple meeting setting records. The records can be filtered, paged, and sorted according to the respective parameters.
 """,
    tags=['meeting_management', 'calendar_event_management'],
)
def post_v2_meetings_settings_searches_json(
    user_guids: Optional[UserGuids] = None,
    updated_at: Optional[UpdatedAt6] = None,
    calendar_type: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List meeting settings
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/meetings/settings/{id}.json',
    description=""" Updates a meeting setting, by ID only.
 """,
    tags=['meeting_management'],
)
def put_v2_meetings_settings__id_json(id: str, request: Request = ...):
    """
    Update a meeting setting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/meetings/{id}.json',
    description=""" Updates a meeting, by ID only.
 """,
    tags=['meeting_management'],
)
def put_v2_meetings__id_json(id: str, request: Request = ...):
    """
    Update a meeting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/mime_email_payloads/{id}.json',
    description=""" Fetch the MIME content for email.
 """,
    tags=['email_management'],
)
def get_v2_mime_email_payloads__id_json(id: str):
    """
    Fetch the MIME content for email
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/notes.json',
    description=""" Fetches multiple note records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['note_management'],
)
def get_v2_notes_json(
    associated_with_type: Optional[str] = None,
    associated_with_id: Optional[int] = None,
    updated_at: Optional[UpdatedAt6] = None,
    ids: Optional[Ids] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List notes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/notes.json',
    description=""" Creates a note.
 """,
    tags=['note_management'],
)
def post_v2_notes_json(request: Request):
    """
    Create a note
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/notes/{id}.json',
    description=""" Deletes a note owned by authorized account.
This operation is not reversible without contacting support.
This operation can be called multiple times successfully.
 """,
    tags=['note_management'],
)
def delete_v2_notes__id_json(id: str):
    """
    Delete a note
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/notes/{id}.json',
    description=""" Fetches a note, by ID only.
 """,
    tags=['note_management'],
)
def get_v2_notes__id_json(id: str):
    """
    Fetch a note
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/notes/{id}.json',
    description=""" Updates a note. Any changes to the note or associated records will not reflect in your CRM.
 """,
    tags=['note_management'],
)
def put_v2_notes__id_json(id: str, request: Request = ...):
    """
    Update a note
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/ongoing_actions.json',
    description=""" Creates an ongoing action. An ongoing action is an action that is not yet completed,
but progress has been made towards the completion. The user should not need to do
anything for an ongoing action to be completed. An ongoing action can be later completed
by creating an activity.

Ongoing actions are marked as status=pending_activity.
 """,
    tags=['action_management', 'activity_management'],
)
def post_v2_ongoing_actions_json(request: Request):
    """
    Create an ongoing action
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/pending_emails.json',
    description=""" Fetches a list of emails ready to be sent by an external email service.
 """,
    tags=['email_management', 'external_email_management'],
)
def get_v2_pending_emails_json(
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    Fetches a list of emails ready to be sent by an external email service. Only emails sent with an External Email Client will appear here.
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/pending_emails/{id}.json',
    description=""" Updates the status of an email sent by an External Email Client. Does not affect lofted emails.
 """,
    tags=['email_management', 'external_email_management'],
)
def put_v2_pending_emails__id_json(id: str, request: Request = ...):
    """
    Updates the status of an email sent by an External Email Client
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/people.json',
    description=""" Fetches multiple person records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['person_management', 'crm_user_management'],
)
def get_v2_people_json(
    ids: Optional[Ids] = None,
    updated_at: Optional[UpdatedAt6] = None,
    email_addresses: Optional[EmailAddresses] = None,
    owned_by_guid: Optional[OwnedByGuid] = None,
    person_stage_id: Optional[PersonStageId] = None,
    crm_id: Optional[CrmId] = None,
    owner_crm_id: Optional[OwnerCrmId] = None,
    do_not_contact: Optional[bool] = None,
    can_email: Optional[bool] = None,
    can_call: Optional[bool] = None,
    can_text: Optional[bool] = None,
    account_id: Optional[AccountId] = None,
    custom_fields: Optional[CustomFields] = None,
    import_id: Optional[ImportId] = None,
    job_seniority: Optional[JobSeniority] = None,
    tag_id: Optional[TagId] = None,
    owner_is_active: Optional[bool] = None,
    cadence_id: Optional[CadenceId] = None,
    starred_by_guid: Optional[StarredByGuid] = None,
    replied: Optional[bool] = None,
    bounced: Optional[bool] = None,
    success: Optional[bool] = None,
    eu_resident: Optional[bool] = None,
    title: Optional[Title] = None,
    country: Optional[Country] = None,
    state: Optional[State] = None,
    city: Optional[City] = None,
    last_contacted: Optional[LastContacted] = None,
    created_at: Optional[CreatedAt3] = None,
    new: Optional[bool] = None,
    phone_number: Optional[bool] = None,
    locales: Optional[Locales] = None,
    owner_id: Optional[OwnerId1] = None,
    field_query: Optional[str] = Query(None, alias='_query'),
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List people
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/people.json',
    description=""" Creates a person. Either email_address or phone/last_name must be provided as a unique lookup
on the team.
 """,
    tags=['person_management'],
)
def post_v2_people_json(request: Request):
    """
    Create a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/people/{id}.json',
    description=""" Deletes a person. This operation is not reversible without contacting support.
This operation can be called multiple times successfully.
 """,
    tags=['account_management', 'person_management', 'user_management'],
)
def delete_v2_people__id_json(id: str):
    """
    Delete a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/people/{id}.json',
    description=""" Fetches a person, by ID only.
 """,
    tags=['person_management', 'account_management'],
)
def get_v2_people__id_json(id: str):
    """
    Fetch a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/people/{id}.json',
    description=""" Updates a person.
 """,
    tags=['person_management', 'account_management'],
)
def put_v2_people__id_json(id: str, request: Request = ...):
    """
    Update a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/person_stages.json',
    description=""" Fetches multiple person stage records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['account_stage_management', 'person_management'],
)
def get_v2_person_stages_json(
    ids: Optional[Ids] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List person stages
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/person_stages.json',
    description=""" Creates a person stage.
 """,
    tags=['person_management', 'account_stage_management'],
)
def post_v2_person_stages_json(request: Request):
    """
    Create a person stage
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/person_stages/{id}.json',
    description=""" Deletes a person stage. This operation is not reversible without contacting support.
This operation can be called multiple times successfully.
 """,
    tags=['account_stage_management', 'person_management'],
)
def delete_v2_person_stages__id_json(id: str):
    """
    Delete an person stage
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/person_stages/{id}.json',
    description=""" Fetches a person stage, by ID only.
 """,
    tags=['account_stage_management', 'person_management'],
)
def get_v2_person_stages__id_json(id: str):
    """
    Fetch a person stage
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/person_stages/{id}.json',
    description=""" Updates a person stage.
 """,
    tags=['account_stage_management', 'person_management'],
)
def put_v2_person_stages__id_json(id: str, request: Request = ...):
    """
    Update a person stage
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/person_upserts.json',
    description=""" Upserts a person record. The upsert_key dictates how the upsert will be performed. The create and update behavior
is exactly the same as the individual create and update endpoints.
 """,
    tags=['account_management', 'person_management'],
)
def post_v2_person_upserts_json(request: Request):
    """
    Upsert a person
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/phone_number_assignments.json',
    description=""" Fetches multiple phone number assignment records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['phone_number_assignment_management', 'phone_number_management'],
)
def get_v2_phone_number_assignments_json(
    ids: Optional[Ids] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List phone number assignments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/phone_number_assignments/{id}.json',
    description=""" Fetches a phone number assignment, by ID only.
 """,
    tags=['phone_number_assignment_management', 'phone_number_management'],
)
def get_v2_phone_number_assignments__id_json(id: str):
    """
    Fetch a phone number assignment
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/phone_numbers/caller_ids.json',
    description=""" Each entry is a possible caller ID match for the number. Multiple
entries may be returned if the phone number is present on more than one
person in the system.  Phone number should be in E.164 format.
 """,
    tags=['phone_number_management', 'call_record_management'],
)
def get_v2_phone_numbers_caller_ids_json(phone_number: str):
    """
    List caller ids
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/phone_numbers/recording_settings/{id}.json',
    description=""" Fetches the recording status for a given phone number, based on Do Not Record and Recording Governance for your team.
Phone number should be in E.164 format.
 """,
    tags=['account_management'],
)
def get_v2_phone_numbers_recording_settings__id_json(id: str):
    """
    Fetch recording setting
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/saved_list_views.json',
    description=""" Fetches multiple saved list view records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['saved_list_view_management'],
)
def get_v2_saved_list_views_json(
    ids: Optional[Ids] = None,
    view: Optional[str] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List saved list views
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/saved_list_views.json',
    description=""" Creates a saved list view.
 """,
    tags=['saved_list_view_management'],
)
def post_v2_saved_list_views_json(request: Request):
    """
    Create a saved list view
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/saved_list_views/{id}.json',
    description=""" Deletes a saved list view. This operation is not reversible without contacting support.
This operation can be called multiple times successfully.
 """,
    tags=['saved_list_view_management'],
)
def delete_v2_saved_list_views__id_json(id: str):
    """
    Delete a saved list view
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/saved_list_views/{id}.json',
    description=""" Fetches a saved list view, by ID only.
 """,
    tags=['saved_list_view_management'],
)
def get_v2_saved_list_views__id_json(id: str):
    """
    Fetch a saved list view
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/saved_list_views/{id}.json',
    description=""" Updates a saved list view.
 """,
    tags=['saved_list_view_management'],
)
def put_v2_saved_list_views__id_json(id: str, request: Request = ...):
    """
    Update a saved list view
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/steps.json',
    description=""" Fetches multiple step records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['cadence_management', 'step_management'],
)
def get_v2_steps_json(
    ids: Optional[Ids] = None,
    cadence_id: Optional[int] = None,
    type: Optional[str] = None,
    has_due_actions: Optional[bool] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List steps
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/steps/{id}.json',
    description=""" Fetches a step, by ID only.
 """,
    tags=['step_management'],
)
def get_v2_steps__id_json(id: str):
    """
    Fetch a step
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/successes.json',
    description=""" Fetches multiple success records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['success_management'],
)
def get_v2_successes_json(
    ids: Optional[Ids] = None,
    person_id: Optional[PersonId] = None,
    updated_at: Optional[UpdatedAt6] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List successes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/tags.json',
    description=""" Fetches a list of the tags used for a team. The records can be filtered, paged, and sorted according to
the respective parameters.

Tags can be applied to mulitple resource types.
 """,
    tags=['success_management', 'team_template_management'],
)
def get_v2_tags_json(
    search: Optional[str] = None,
    ids: Optional[Ids] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List team tags
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/tasks.json',
    description=""" Fetches multiple task records. The records can be filtered, paged, and sorted according to
the respective parameters.
 """,
    tags=['task_management', 'activity_management'],
)
def get_v2_tasks_json(
    ids: Optional[Ids] = None,
    user_id: Optional[UserId] = None,
    person_id: Optional[PersonId] = None,
    account_id: Optional[AccountId] = None,
    current_state: Optional[CurrentState] = None,
    task_type: Optional[TaskType] = None,
    time_interval_filter: Optional[str] = None,
    idempotency_key: Optional[str] = None,
    locale: Optional[Locale] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List tasks
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/tasks.json',
    description=""" Creates a task.
 """,
    tags=['task_management'],
)
def post_v2_tasks_json(request: Request):
    """
    Create a Task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/tasks/{id}.json',
    description=""" Fetches a task, by ID only.
 """,
    tags=['task_management'],
)
def get_v2_tasks__id_json(id: str):
    """
    Fetch a task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/tasks/{id}.json',
    description=""" Updates a task.
 """,
    tags=['task_management'],
)
def put_v2_tasks__id_json(id: str, request: Request = ...):
    """
    Update a Task
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/team.json',
    description=""" Fetches the team of the authenticated user.
 """,
    tags=['account_management', 'user_management', 'group_management'],
)
def get_v2_team_json():
    """
    Fetch current team
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/team_template_attachments.json',
    description=""" Fetches multiple team template attachment records. The records can be filtered and paged according to
the respective parameters.
 """,
    tags=['team_template_management'],
)
def get_v2_team_template_attachments_json(
    ids: Optional[Ids] = None,
    team_template_id: Optional[TeamTemplateId] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List team template attachments
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/team_templates.json',
    description=""" Fetches multiple team template records. The records can be filtered, paged, and sorted according to
the respective parameters.

Team templates are templates that are available team-wide. Admins may use
team templates to create original content for the entire team, monitor version control to ensure templates are always up to date,
and track template performance across the entire organization. All metrics on a team template reflect usage across the team; individual metrics can be found with the email_templates API endpoint.
 """,
    tags=['team_template_management'],
)
def get_v2_team_templates_json(
    ids: Optional[Ids28] = None,
    updated_at: Optional[UpdatedAt6] = None,
    search: Optional[str] = None,
    tag_ids: Optional[TagIds] = None,
    tag: Optional[Tag1] = None,
    include_archived_templates: Optional[bool] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    limit_paging_counts: Optional[bool] = None,
):
    """
    List team templates
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/team_templates/{id}.json',
    description=""" Fetches a team template, by ID only.
 """,
    tags=['team_template_management'],
)
def get_v2_team_templates__id_json(id: str, include_signature: Optional[bool] = None):
    """
    Fetch a team template
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/third_party_live_feed_items',
    description=""" Creates a live feed item that can be sent to users. May only be used by whitelisted Frontend Integrations. Reference the Salesloft App Directory and Frontend Integrations sections for additional details. """,
    tags=['activity_management', 'action_management'],
)
def post_v2_third_party_live_feed_items(request: Request):
    """
    Create a live feed item
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/users.json',
    description=""" Non Admin: Lists only your user, or all on team depending on group visibility policy
Team Admin: Lists users associated with your team
 """,
    tags=['user_management', 'crm_user_management'],
)
def get_v2_users_json(
    ids: Optional[Ids29] = None,
    guid: Optional[Guid] = None,
    group_id: Optional[GroupId1] = None,
    role_id: Optional[RoleId] = None,
    search: Optional[str] = None,
    active: Optional[bool] = None,
    visible_only: Optional[bool] = None,
    per_page: Optional[int] = None,
    page: Optional[int] = None,
    include_paging_counts: Optional[bool] = None,
    has_crm_user: Optional[bool] = None,
    work_country: Optional[WorkCountry] = None,
    sort_by: Optional[str] = None,
    sort_direction: Optional[str] = None,
):
    """
    List users
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/users/{id}.json',
    description=""" Fetches a user, by ID only.
 """,
    tags=['user_management', 'account_management'],
)
def get_v2_users__id_json(id: str):
    """
    Fetch a user
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/webhook_subscriptions',
    description=""" Fetches all of the customer's webhook subscriptions for your application. """,
    tags=['webhook_management'],
)
def get_v2_webhook_subscriptions(enabled: Optional[bool] = None):
    """
    List webhook subscriptions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/v2/webhook_subscriptions',
    description=""" Creates a webhook subscription. Visit the <a href="/webhooks.html" target="_blank" rel="noopener noreferrer">webhooks page</a> for additional details and a list of available webhooks.
Request must be made with a valid Oauth token or API key. """,
    tags=['webhook_management'],
)
def post_v2_webhook_subscriptions(request: Request):
    """
    Create a webhook subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.delete(
    '/v2/webhook_subscriptions/{id}',
    description=""" Deletes a webhook subscription. This operation is not reversible without contacting support. This operation can be called multiple times successfully. """,
    tags=['webhook_management'],
)
def delete_v2_webhook_subscriptions__id(id: int):
    """
    Delete a webhook subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/v2/webhook_subscriptions/{id}',
    description=""" Fetches a webhook subscription, by ID only. """,
    tags=['webhook_management'],
)
def get_v2_webhook_subscriptions__id(id: int):
    """
    Fetch a webhook subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.put(
    '/v2/webhook_subscriptions/{id}',
    description=""" Updates a webhook subscription.
Request must be made with a valid Oauth token or API key. """,
    tags=['webhook_management'],
)
def put_v2_webhook_subscriptions__id(id: int, request: Request = ...):
    """
    Update a webhook subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
